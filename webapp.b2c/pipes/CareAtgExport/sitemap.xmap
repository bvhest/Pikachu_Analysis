<?xml version="1.0"?>
<map:sitemap xmlns:map="http://apache.org/cocoon/sitemap/1.0">
  <map:components>
    <map:transformers default="xslt">
      <map:transformer name="shell" src="org.apache.cocoon.transformation.FileActionsTransformer"/>
    </map:transformers>    
    <map:actions>
      <map:action name="synced-copy-source" src="org.apache.cocoon.acting.SyncedCopySourceAction"/>
    </map:actions>
  </map:components>
  
    <map:resources>
    <!-- the sql resource provides a central place to edit database details -->
    <map:resource name="sql">
      <map:transform type="sql">
        <map:parameter name="use-connection" value="oracleDbCMC"/>
        <map:parameter name="clob-encoding" value="UTF-8"/>
      </map:transform>
    </map:resource>
    </map:resources>
    <!-- -->
  
<!-- How the export works.
   1. Select Locales to be exported (and reset previously batched products (leftovers from a previous run))
   2. Batch up products
   3. Process data on a locale|batch basis.
   Two export modes exists. Full database read and the delta database read extract.
   Irrespective of the database extract mode a normalized delta export is performed for ATG
   The modes are selected via a request parameter. delta='y' for delta extract from database.
   Full database read.
      1. selectExportProducts sets flags in customer_locale_export (cle) for products to be exported.
      2. All products are extracted for a batch from the database and permanently stored in the cache directory.
         All products are needed for data normalization. Flags set in cle are ignored.
      3. The LastExportedTimestamp is added to the Product xml as an attribute to each product.
      4. Product data is normalized and formatted for ATG.
      5. Report on what is exported is generated base on flags set in cle.
   Delta database Read
      note: This pipeline will be invoked only with maximum batch number for a delta read.
      1. selectExportProducts sets flags in customer_locale_export (cle) for products to be exported.
      2. Only products with flag set in cle are extracted from the database.
      3. Extracted products are merged with the products (maximum batch number) stored in the cache directory. The result is resaved in this batch file.
      4. The LastExportedTimestamp is added to the Product xml as an attribute to each product.
      4. Product data is normalized and formatted for ATG.
      5. Report on what is exported is generated base on flags set in cle.
-->      
   
  <map:pipelines>
    <!--- -->
    <map:component-configurations>
      <global-variables>
        <ldir>CareAtgExport/</ldir>
        <channel>CareAtgExport</channel>
        <contentType>PCT</contentType>
      </global-variables>
    </map:component-configurations>
    <!--- -->
    <map:pipeline name="{global:channel}" type="noncaching">
      <!--- -->   
       <map:match pattern="runPipeline">
        <map:act type="synced-copy-source" src="cocoon:/exportStart">
          <map:parameter name="lockName" value="{global:channel}"/>
          <map:parameter name="dest" value="{global:gdir}{global:ldir}temp/import.xml"/>
          <map:generate src="{global:gdir}{global:ldir}temp/import.xml"/>
          <map:serialize type="xml"/>
        </map:act>
        <map:generate src="../common/xml/locked.xml"/>
        <map:serialize type="xml"/>
      </map:match>
      <!-- -->
      <map:match pattern="exportStart">
        <!-- Set Start Time.of this channel-->
        <map:act type="copy-source" src="cocoon:/runsql_setstarttime">
          <map:parameter name="dest" value="{global:gdir}{global:ldir}temp/ReportSetStartTime.xml"/>
        </map:act>
        <!-- Call the Main Export.-->
        <map:act type="copy-source" src="cocoon:/exportMain">
          <map:parameter name="dest" value="{global:gdir}{global:ldir}temp/ReportExportMain.xml"/>
        </map:act>
        <!-- Set End Time of this channel-->
        <map:act type="copy-source" src="cocoon:/runsql_setendtime">
          <map:parameter name="dest" value="{global:gdir}{global:ldir}temp/ReportSetEndTime.xml"/>
        </map:act>
        <!-- Show result -->
        <map:act type="copy-source" src="cocoon:/runsql_gettimings">
          <map:parameter name="dest" value="{global:gdir}{global:ldir}temp/ReportGetTimings.xml"/>
        </map:act>
        <map:generate src="{global:gdir}{global:ldir}temp/ReportGetTimings.xml"/>
        <map:serialize type="xml"/>
      </map:match>
      <!-- set Start / End Time -->
      <map:match pattern="runsql_*">
        <map:generate src="../common/xml/empty.xml"/>
          <map:select type="parameter">
            <map:parameter name="parameter-selector-test" value="{request-param:delta}"/>
            <map:when test="y">
              <map:transform type="xslt-saxon" src="../common/xsl/{global:db}sql_{1}.xsl">
                <map:parameter name="channel" value="{global:channel}"/>
                 <map:parameter name="run_id" value="{request-param:runId}"/>
                 <map:parameter name="run_mode" value="{request-param:runmode}"/>
              </map:transform>
            </map:when>
            <map:otherwise>
              <map:transform type="xslt-saxon" src="../common/xsl/{global:db}sql_{1}.xsl">
                <map:parameter name="channel" value="{global:channel}FullExtract"/>
                 <map:parameter name="run_id" value="{request-param:runId}"/>
                 <map:parameter name="run_mode" value="{request-param:runmode}"/>
              </map:transform>           
            </map:otherwise>
          </map:select>
        <!-- Run db queries -->
        <map:call resource="sql"/>
        <map:serialize type="xml"/>
      </map:match>
      <!-- -->
      <map:match pattern="exportMain">
        <!-- Delete all files in the {global:gdir}{global:ldir}temp directory. Write the results of this action to a report.-->
        <map:act type="copy-source" src="cocoon:/deleteTempFiles">
          <map:parameter name="dest" value="{global:gdir}{global:ldir}temp/ReportDeleteTmpFilesReport.xml"/>
        </map:act>
        <!-- retrieve data needed later -->
        <map:act type="copy-source" src="cocoon:/getLocaleLanguage">
          <map:parameter name="dest" value="{global:gdir}{global:ldir}temp/LocaleLanguage.xml"/>
        </map:act>   
        <!-- Loop over all languages -->
        <map:generate src="../common/xml/empty.xml"/>
        <map:transform src="xsl/{global:db}sql_getlocales.xsl" >
          <map:parameter name="channel" value="{global:channel}"/>
          <map:parameter name="delta" value="{request-param:delta}"/>
        </map:transform>
        <map:call resource="sql"/>
        <!-- Transform output to get include statements to exportSub-->
        <map:transform type="xslt-saxon" src="xsl/ll2includeForBatching.xsl" />
        <!-- Execute the includes-->
        <map:transform type="cinclude" />
        <!-- Generate report for products -->
        <map:transform type="xslt-saxon" src="xsl/makereport.xsl" >
          <map:parameter name="channel" value="{global:channel}"/>
          <map:parameter name="exportdate" value="{1}"/>
          <map:parameter name="dir" value="{global:gdir}{global:ldir}"/>
        </map:transform>
        <!-- Write report to disk -->
        <map:transform type="write-source" />
        <!-- Get the run timestamp -->
        <map:transform type="xslt-saxon" src="xsl/sql_gettimestamp.xsl" >
          <map:parameter name="channel" value="{global:channel}"/>
          <map:parameter name="delta" value="{request-param:delta}"/>
        </map:transform>
        <map:call resource="sql"/>       
        <!-- Transform output to get include statements to createContentReady -->
        <map:transform type="xslt-saxon" src="xsl/createContentReady.xsl" >
            <map:parameter name="delta" value="{request-param:delta}"/>
        </map:transform>
        <!-- Execute the includes-->
        <map:transform type="cinclude" />          
        <!-- Reset batch numbers to zero in CLE table-->
        <map:transform type="xslt-saxon" src="xsl/sql_updateCLE.xsl" label="step3">
          <map:parameter name="channel" value="{global:channel}"/>
        </map:transform>
        <map:call resource="sql"/>          
        <map:serialize type="xml"/>
      </map:match>
      <!-- -->
      <map:match pattern="batchSub.*.*.*.*">
        <!-- {1} timestamp    {2} country {3} locale {4} content_type -->  
        <!-- Idenfity and batch products, ordering on MASTERLASTMODIFIED DESC -->
        <map:generate src="../common/xml/empty.xml"/>    
        
        <!-- This step adds records to the customer_locale_export table for new products and flags all records for which the lasttransmit 
           | date is older than the product.lastmodified_ts of the catalog_product.lastmodified_ts. -->
        <map:act type="copy-source" src="cocoon:/selectExportProducts.{3}.{4}">
          <map:parameter name="dest" value="{global:gdir}{global:ldir}temp/ReportSelectExportProducts_{3}.{4}.xml"/>
        </map:act>
        
        <!-- This batches all flagged entries ordering them descending master last modified date 
           | The batching covers all records unconditionally of whether they will be exported -->
        <map:transform type="xslt-saxon" src="xsl/sql_createbatches.xsl">
          <map:parameter name="batchsize" value="1000"/>
          <map:parameter name="country" value="{2}"/>                
          <map:parameter name="locale" value="{3}"/>                
          <map:parameter name="channel" value="{global:channel}"/>
          <map:parameter name="contentType" value="{4}"/>
        </map:transform>
        <map:call resource="sql"/>   
        
        <!-- From now on the processing will be on a locale/batched basis. The distinct locales and batches are selected and ordered here.
                          output is:- locale | batch number | number_ctns in a batch | maximum batch number -->
        <map:transform type="xslt-saxon" src="xsl/sql_selectbatches.xsl" >
          <map:parameter name="locale" value="{3}"/>
          <map:parameter name="channel" value="{global:channel}"/>
          <map:parameter name="contentType" value="{4}"/>
        </map:transform>
        <map:call resource="sql"/>
        
        <!-- invokes exportSub pipeline. If there are no ctns to be exported for a locale and delta='y'  then processing stops here --> 
        <map:transform type="xslt-saxon" src="xsl/ll2include.xsl" >
          <map:parameter name="timestamp" value="{1}"/>
          <map:parameter name="country" value="{2}"/>
          <map:parameter name="locale" value="{3}"/>                
          <map:parameter name="channel" value="{global:channel}"/>
          <map:parameter name="delta" value="{request-param:delta}"/>
          <map:parameter name="contentType" value="{4}"/>
        </map:transform>        
        <map:transform type="cinclude" />                        
        <map:serialize type="xml"/>        
      </map:match>


      <map:match pattern="exportSub.*.*.*.*.*.*">
        <!-- export per locale  {1} timestamp, {2} country {3} locale  {4} batch number  {5} max batch number {6} content_type-->
        <!-- this is the MAIN SELECTOR. It sets the flag in the customer_locale_export tables for products to be exported -->

       
        <map:select type="parameter">
          <map:parameter name="parameter-selector-test" value="{request-param:delta}"/>
          <map:when test="y">
            <!-- Extract new products from database. merge  and resave with products in cache directory -->
            <map:act type="copy-source" src="cocoon:/aggregateData.{3}.{4}.{6}">
               <map:parameter name="dest" value="{global:gdir}{global:ldir}cache/PhilipsCatalog_{3}.{4}.xml"/>
            </map:act>         
          </map:when>
          <map:when test="resend"/>
          <map:otherwise>
            <!-- Extract all products from database and save in cache directory -->
            <map:act type="copy-source" src="cocoon:/exportLocaleFiles.{3}.{4}.{6}">
              <map:parameter name="dest" value="{global:gdir}{global:ldir}cache/PhilipsCatalog_{3}.{4}.xml"/>
            </map:act>
          </map:otherwise>
        </map:select>
        <!-- get last exported timestamp from the cle and add as attributes to the products -->
        <map:act type="copy-source" src="cocoon:/addLastExportTimestamps.{3}.{4}">
          <map:parameter name="dest" value="{global:gdir}{global:ldir}temp/PhilipsCatalog_{3}.{4}.xml"/>
        </map:act>
        <!-- Normalise and format data for ATG -->
        <map:act type="copy-source" src="cocoon:/exportData.{1}.{2}.{3}.{4}">
          <map:parameter name="dest" value="{global:gdir}{global:ldir}temp/exportData_{3}.{4}.xml"/>
        </map:act>
        
        
        
        <map:generate src="{global:gdir}{global:ldir}temp/exportData_{3}.{4}.xml"/>
        <map:serialize type="xml"/>
      </map:match>
      

      <map:match pattern="aggregateData.*.*.*">
        <!-- export per locale  {1} locale   {2} batch number {3} content_type -->
        <map:select type="resource-exists">
        <map:when test="{global:gdir}{global:ldir}cache/PhilipsCatalog_{1}.{2}.xml">     
          <map:aggregate element="root">
            <map:part src="cocoon:/exportLocaleFiles.{1}.{2}.{3}"/>
            <map:part src="{global:gdir}{global:ldir}cache/PhilipsCatalog_{1}.{2}.xml"/>
          </map:aggregate>         
        </map:when>
        <map:otherwise>
          <map:generate  src="cocoon:/exportLocaleFiles.{1}.{2}.{3}?delta=n"/>
        </map:otherwise>
        </map:select>
        <map:transform type="xslt-saxon" src="xsl/merge_aggregation.xsl"/>               
        <map:serialize type="xml"/>
      </map:match>
         
      
      <map:match pattern="addLastExportTimestamps.*.*">
        <map:generate src="{global:gdir}{global:ldir}cache/PhilipsCatalog_{1}.{2}.xml"/>
        <map:transform type="xslt-saxon" src="xsl/sql_getLastExportTimestamps.xsl">
          <map:parameter name="locale" value="{1}"/>
          <map:parameter name="channel" value="{global:channel}"/>
        </map:transform>   
        <map:call resource="sql"/>
        <map:transform type="xslt-saxon" src="xsl/formatLastExportTimestamps.xsl"/>
        <map:serialize type="xml"/>
      </map:match>

      <map:match pattern="exportData.*.*.*.*">
            <!-- export per locale  {1} timestamp, {2} country {3} locale  {4} batch number -->
 
        <map:act type="copy-source" src="cocoon:/exportAtg.Product.{3}.{4}">
          <map:parameter name="dest" value="{global:gdir}{global:ldir}outbox/{1}-{2}-{3}-ctv.xml"/>
        </map:act>
        <map:act type="copy-source" src="cocoon:/genReport.{1}.{3}.{4}">
          <map:parameter name="dest" value="{global:gdir}{global:ldir}temp/FinalReport_{1}_{3}_{4}.xml"/>
        </map:act>
        <!-- english catalog explosion -->   
        <map:select type="resource-exists">
          <map:when test="{global:gdir}{global:ldir}outbox/{1}-global-master_global-ctv.xml">
             <map:act type="copy-source" src="cocoon:/explodeEnglish.{1}">
              <map:parameter name="dest" value="{global:gdir}{global:ldir}temp/explodeEnglish_{1}.xml"/>
            </map:act>         
          </map:when>
          <map:otherwise/>
        </map:select>
        <map:act type="copy-source" src="cocoon:/archiveFiles.{3}.{1}">
          <map:parameter name="dest" value="{global:gdir}{global:ldir}temp/ArchiveFiles_{1}_{3}_{4}.xml"/>
        </map:act>
        <map:generate src="{global:gdir}{global:ldir}temp/FinalReport_{1}_{3}_{4}.xml"/>
        <map:serialize type="xml"/>
      </map:match>
      <!-- -->
      <map:match pattern="exportAtg.*.*.*">
        <!-- export per locale  {1} type  {2} locale  {3} batch number -->
        <map:generate src="{global:gdir}{global:ldir}temp/PhilipsCatalog_{2}.{3}.xml"/>
        <map:transform type="xslt-saxon" src="xsl/Atg{1}.xsl">
          <map:parameter name="doctypesfilepath" value="{cmc2:xmlDir}/doctype_attributes.xml"/>
          <map:parameter name="localelanguagefilepath" value="{cmc2:gdir}/{global:ldir}temp/LocaleLanguage.xml"/>
          <map:parameter name="locale" value="{2}"/>
        </map:transform>
        <map:serialize type="xml"/>
      </map:match>
      <!-- -->
      <map:match pattern="selectExportProducts.*.*">
         <!-- export per locale   {1} locale    {2} content_type -->
        <map:generate src="../common/xml/empty.xml"/>
        <map:transform type="xslt-saxon" src="xsl/{global:db}sql_selectproducts.xsl">
          <map:parameter name="locale" value="{1}"/>
          <map:parameter name="channel" value="{global:channel}"/>
          <map:parameter name="contentType" value="{2}"/>
               <map:parameter name="delta" value="{request-param:delta}"/>
        </map:transform>
        <map:call resource="sql"/>
        <map:serialize type="xml"/>
      </map:match>
      <!-- -->
      <map:match pattern="testConvert">
        <map:generate src="xsl/testProduct.xml"/>
        <map:transform type="xslt-saxon" src="xsl/convertProducts.xsl"/>
        <map:serialize type="xml"/>
      </map:match>
      <!-- -->
         <map:match pattern="exportLocaleFiles.*.*.*">
        <!-- export per locale  {1} locale {2} batch {3} content_type-->
        <map:generate src="../common/xml/empty.xml" />
        <map:transform type="xslt-saxon" src="xsl/{global:db}sql_getlocaleproducts.xsl">
          <map:parameter name="locale" value="{1}"/>
          <map:parameter name="batchnumber" value="{2}"/>
          <map:parameter name="channel" value="{global:channel}"/>
          <map:parameter name="contentType" value="{3}"/>
          <map:parameter name="delta" value="{request-param:delta}"/>
        </map:transform>       
        <map:call resource="sql"/>          
        <!-- transform output-->
        <map:transform type="xslt-saxon" src="xsl/convertProducts.xsl" >
          <map:parameter name="doctypesfilepath" value="{cmc2:xmlDir}/doctype_attributes.xml"/>
        </map:transform>       
        <map:transform type="xslt-saxon" src="xsl/sql_clean.xsl" />
        <map:serialize type="xml"/>
      </map:match>
       <!-- -->
      <map:match pattern="getLocaleLanguage">
        <map:generate src="../common/xml/empty.xml" />
        <map:transform type="xslt-saxon" src="xsl/{global:db}sql_getLocaleLanguage.xsl"/>
        <map:call resource="sql"/>
        <map:transform type="xslt-saxon" src="xsl/localeLanguage.xsl" />
        <map:serialize type="xml"/>
      </map:match>
      <!-- -->
      <map:match pattern="genReport.*.*.*">
        <map:generate src="../common/xml/empty.xml"/>
        <map:transform src="xsl/sql_genreport.xsl">
          <map:parameter name="exportdate" value="{1}"/>
          <map:parameter name="locale" value="{2}"/>
          <map:parameter name="batchnumber" value="{3}"/>
          <map:parameter name="channel" value="{global:channel}"/>
               <map:parameter name="delta" value="{request-param:delta}"/>
        </map:transform>
        <map:call resource="sql"/>
        <map:serialize type="xml"/>
      </map:match>
      <!-- Create CONTENT-READY file -->
      <map:match pattern="createCONTENTREADY.*">
        <map:generate src="../common/xml/empty.xml"/>
        <map:act type="copy-source" src="../common/xml/empty.xml">
          <map:parameter name="dest" value="{global:gdir}{global:ldir}archive/{1}/CONTENT-READY"/>
        </map:act>
         <map:act type="copy-source" src="../common/xml/empty.xml">
          <map:parameter name="dest" value="{global:gdir}{global:ldir}oracleTableData/{1}/CONTENT-READY"/>
        </map:act>
        <map:serialize type="xml"/>        
      </map:match>
      <!-- -->
      <map:match pattern="repository2TableData.*.*">
       <!-- {1} locale   {2} timestamp -->
        <map:generate type="directory" src="{global:gdir}{global:ldir}outbox" >
          <map:parameter name="dateFormat" value="yyyy-MM-dd hh:mm"/>
          <map:parameter name="depth" value="1"/>
          <map:parameter name="include" value=".*"/>
        </map:generate>
        <map:transform src="xsl/include_file2process.xsl" >
          <map:parameter name="process" value="file2TableData" />
          <map:parameter name="locale"    value="{1}"/>
          <map:parameter name="timestamp" value="{2}"/>
        </map:transform>
        <map:transform type="cinclude"/>
        <map:serialize type="xml"/>
      </map:match>
      <!-- -->
      <map:match pattern="file2TableData.*.*.**">
       <!-- {1} locale   {2} timestamp  {3} filename -->
        <map:generate src="{global:gdir}{global:ldir}outbox/{3}"/>
        <map:transform type="xslt-saxon" src="xsl/tp2Table.xsl" />
        <map:transform type="xslt-saxon" src="xsl/write_tableData.xsl" >
         <map:parameter name="path" value="{global:gdir}{global:ldir}oracle"/>
        </map:transform> 
        <map:transform type="write-source">
        </map:transform>
        <map:serialize type="xml"/>
      </map:match>
 
      <map:match pattern="buildExternalTables">
        <map:generate src="cocoon:/getAtgTableMetadata"/>
         <map:transform type="xslt-saxon" src="xsl/sql_createAtgSchemaObjects.xsl"> 
          <map:parameter name="external_only" value="y"/>
         </map:transform>  
         <map:transform type="sql">
          <map:parameter name="use-connection" value="oracleDbAtg"/>
          <map:parameter name="clob-encoding" value="UTF-8"/>
        </map:transform>
        <map:serialize type="xml"/>
      </map:match>
      
       <map:match pattern="buildLoaderProcedure">
        <map:generate src="cocoon:/getAtgTableMetadata"/>
        <map:transform type="xslt-saxon" src="xsl/sql_createLoaderProcedure.xsl"/> 

         <map:transform type="sql">
          <map:parameter name="use-connection" value="oracleDbAtg"/>
          <map:parameter name="clob-encoding" value="UTF-8"/>
        </map:transform>
        <!-- -->
        <map:serialize type="xml"/>
      </map:match>
      
       <map:match pattern="getAtgTableMetadata">
        <map:generate src="xsl/customCatalogCombined.xml"/>
        <map:transform type="xslt-saxon" src="xsl/tableTypes.xsl" />
        <map:transform type="xslt-saxon" src="xsl/sql_getTableMetadata.xsl" />
        <map:transform type="sql">
          <map:parameter name="use-connection" value="oracleDbAtg"/>
          <map:parameter name="clob-encoding" value="UTF-8"/>
        </map:transform>            
         <map:transform type="xslt-saxon" src="xsl/formatTableMetadata.xsl"/> 
        <map:serialize type="xml"/>
      </map:match>
    
      <!-- -->
      <map:match pattern="deleteTempFiles">
        <!-- Delete all files in {global:gdir}{global:ldir}temp directory -->
        <map:generate type="directory" src="{global:gdir}{global:ldir}temp">
          <map:parameter name="dateFormat" value="yyyy-MM-dd hh:mm"/>
          <map:parameter name="depth" value="1"/>
          <map:parameter name="include" value=".*"/>
        </map:generate>
        <!-- Delete all files -->
        <map:transform src="../common/xsl/dir2shell_delete.xsl" >
          <map:parameter name="dir" value="{global:gdir}{global:ldir}temp"/>
        </map:transform>
        <map:transform type="shell" />
        <map:serialize type="xml"/>
      </map:match>
      
      <map:match pattern="archiveFiles.*.*">
        <map:generate type="directory" src="{global:gdir}{global:ldir}outbox">
          <map:parameter name="dateFormat" value="yyyy-MM-dd hh:mm"/>
          <map:parameter name="depth" value="1"/>
          <map:parameter name="include" value=".*"/>
        </map:generate>     
        <!-- Move files to archive -->
        <map:transform type="xslt-saxon" src="xsl/dir2shell_move.xsl">
          <map:parameter name="sourceDir" value="{global:gdir}{global:ldir}outbox"/>
          <map:parameter name="targetDir" value="{global:gdir}{global:ldir}archive"/>
          <map:parameter name="locale"    value="{1}"/>
          <map:parameter name="timestamp" value="{2}"/>
        </map:transform> 
        <map:transform type="shell"/>
        <map:serialize type="xml"/>
      </map:match>
      <!-- -->
      
      <!-- english catalog explosion -->   
      <map:match pattern="explodeEnglish.*">
         <map:generate src="../common/xml/empty.xml"/>
        <map:transform type="xslt-saxon" src="xsl/sql_getEnglishCountries.xsl">
               <map:parameter name="channel" value="{global:channel}"/>
            </map:transform>
        <map:call resource="sql"/>
        <!-- Transform output to get include statements to exportSub-->
        <map:transform type="xslt-saxon" src="xsl/include_english.xsl">
          <map:parameter name="timestamp"  value="{1}"/>
        </map:transform>
        <!-- Execute the includes-->
        <map:transform type="cinclude" />
        <map:serialize type="xml"/>
      </map:match>
      <!-- -->
       <map:match pattern="english.*.*">
        <!-- {1} timestamp {2} country -->
        <map:select type="resource-exists">
          <map:when test="{global:gdir}{global:ldir}temp/catalog_{2}.xml"/>
          <map:otherwise>
            <map:act type="copy-source" src="cocoon:/getCatalogProducts.{2}">
              <map:parameter name="dest" value="{global:gdir}{global:ldir}temp/catalog_{2}.xml"/>
            </map:act>
          </map:otherwise>
        </map:select>
        <map:act type="copy-source" src="cocoon:/master2english.{1}.{2}">
          <map:parameter name="dest" value="{global:gdir}{global:ldir}outbox/{1}-{2}-en_{2}-ctv.xml"/>
        </map:act>
        <map:generate src="../common/xml/empty.xml"/>
        <map:serialize type="xml"/>
      </map:match>     
      <!-- -->
      <map:match pattern="getCatalogProducts.*">
         <!-- export per locale   {1} country   -->
        <map:generate src="../common/xml/empty.xml"/>
        <map:transform type="xslt-saxon" src="xsl/sql_getCatalogProducts.xsl">
          <map:parameter name="country" value="{1}"/>
        </map:transform>
        <map:call resource="sql"/>
        <map:serialize type="xml"/>
      </map:match>      
      <!-- -->
      <map:match pattern="master2english.*.*">
         <!-- export per locale   {1} timestamp {2} country  -->
        <map:generate src="{global:gdir}{global:ldir}outbox/{1}-global-master_global-ctv.xml"/>
         <map:transform type="xslt-saxon" src="xsl/catalogFilter.xsl">
          <map:parameter name="country" value="{2}"/>
          <map:parameter name="catalogDocPath" value="../{global:gdir}{global:ldir}temp/catalog_{2}.xml"/>
        </map:transform>
        <map:transform type="xslt-saxon" src="xsl/master2english.xsl">
          <map:parameter name="country" value="{2}"/>
        </map:transform>
        <map:serialize type="xml"/>
      </map:match>
      <!-- -->
      <!-- -->
    </map:pipeline>
  </map:pipelines>
  <!-- -->
  
  <!-- -->
</map:sitemap>
