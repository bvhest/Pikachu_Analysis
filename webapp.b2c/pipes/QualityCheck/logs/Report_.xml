<?xml version="1.0" encoding="UTF-8"?><report><xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0">
  
  <xsl:template match="@*|node()">
    <xsl:copy copy-namespaces="no">
      <xsl:apply-templates/>
    </xsl:copy>
  </xsl:template>
  
  <xsl:template match="/root">
    <xsl:copy copy-namespaces="no">
      <xsl:apply-templates select="entries/entry"/>
    </xsl:copy>
  </xsl:template>
  
  <xsl:template match="entry">
    <xsl:copy copy-namespaces="no">
      <xsl:apply-templates select="@*|result"/>
    </xsl:copy>
  </xsl:template>
</xsl:stylesheet><xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0">
  
  <xsl:template match="@*|node()" mode="#all">
    <xsl:copy copy-namespaces="no">
      <xsl:apply-templates mode="#current" select="@*|node()"/>
    </xsl:copy>
  </xsl:template>
  
  <xsl:template match="sourceResult|source:*|shellResult|shell:*"/>
</xsl:stylesheet><xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0">
  
  <xsl:strip-space elements="*"/>

  <xsl:template match="@*|node()" mode="#all">
    <xsl:copy copy-namespaces="no">
      <xsl:apply-templates mode="#current" select="@*|node()"/>
    </xsl:copy>
  </xsl:template>

  <xsl:template match="root">
    <xsl:copy copy-namespaces="no">
      <delta>
        <xsl:apply-templates mode="clean" select="delta/ProductsMsg"/>
      </delta>
      <cache>
        <xsl:apply-templates mode="clean" select="cache/ProductsMsg"/>
      </cache>  
      <store>
        <xsl:apply-templates select="delta/ProductsMsg"/>
      </store>
    </xsl:copy>
  </xsl:template>
  
  <!-- filtered elements and attributes -->
  <xsl:template match="@version|@docTimestamp|Modified|Asset[Publisher='ProCoon']" mode="clean"/>
  <!-- Remove Obsolete Assets from inbox XML -->
  <xsl:template match="delta/ProductsMsg/Product/Asset[License='Obsolete']" mode="clean"/>
  
  <xsl:template match="Product" mode="clean">
    <xsl:copy copy-namespaces="no">
      <xsl:apply-templates select="CTN"/>
      <xsl:apply-templates mode="clean" select="Asset">
        <xsl:sort order="ascending" select="ResourceType"/>
        <xsl:sort order="ascending" select="Language"/>
      </xsl:apply-templates>
    </xsl:copy>
  </xsl:template>
</xsl:stylesheet><xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0">

  <xsl:template match="@*|node()">
    <xsl:copy>
      <xsl:apply-templates select="@*|node()"/>
    </xsl:copy>
  </xsl:template>
  
  <xsl:template match="AssetsToCompare">
    <xsl:copy copy-namespaces="no">
      <xsl:choose>
        <xsl:when test="deep-equal(ProductsMsg[1]/Product,ProductsMsg[2]/Product)">
          <remove ctn="{ProductsMsg[1]/Product/CTN}"/>
        </xsl:when>
        <xsl:otherwise>
          <keep ctn="{ProductsMsg[1]/Product/CTN}">
            <xsl:apply-templates select="store"/>
          </keep>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:copy>
  </xsl:template>

  <xsl:template match="root">
    <FilterAssets>
      <xsl:choose>
         <xsl:when test="deep-equal(delta/ProductsMsg/Product,cache/ProductsMsg/Product)">
           <remove ctn="{delta/ProductsMsg/Product/CTN}"/>
         </xsl:when>
         <xsl:otherwise>
           <keep ctn="{delta/ProductsMsg/Product/CTN}">
            <xsl:apply-templates select="store"/>
          </keep>
         </xsl:otherwise>
      </xsl:choose>
    </FilterAssets>
  </xsl:template>  
</xsl:stylesheet><xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" extension-element-prefixes="cmc2-f" version="2.0">
  
  <xsl:param name="ct"/>
  <xsl:param name="l"/>
  <xsl:param name="ts"/>
  <xsl:param name="dir"/>
  <xsl:param name="batchnumber"/>
  <xsl:include href="../../../xsl/common/cmc2.function.xsl"/>
  <xsl:variable name="processTimestamp" select="cmc2-f:formatDate($ts)"/>


  <!-- AsselList   C O N T E N T  T Y P E    master_global -->
  <xsl:template match="Product">
    <xsl:variable name="docTimestamp" select="../@docTimestamp"/>
    <xsl:variable name="masterLastmodifiedTimestamp">
      <xsl:analyze-string regex="^(..)/(..)/(..)T(........).*$" select="$docTimestamp">
        <xsl:matching-substring>
          <value>
            <xsl:value-of select="concat( '20',regex-group(3),'-',regex-group(1),'-',regex-group(2),'T',regex-group(4) )"/>
          </value>
        </xsl:matching-substring>
        <xsl:non-matching-substring>
          <!-- assume alternative date format -->
          <value>
            <xsl:value-of select="$docTimestamp"/>
          </value>
        </xsl:non-matching-substring>
      </xsl:analyze-string>
    </xsl:variable>
    <!-- the content type will not be known in the file so is passed in-->
    <xsl:variable name="objectId" select="CTN"/>
    <xsl:variable name="contentType" select=" 'AssetList' "/>
    <xsl:variable name="localisation" select=" 'master_global' "/>
    <xsl:if test="Asset[Language = ''                         or Language='en_Philips'                         or (Language = 'en_US' and ResourceType=('GLL', 'MSD', 'WRN', 'DOC', 'INI', 'SMA', 'L3D',  'CER') )                         or (Language = 'en_US' and ResourceType='PSS')][Publisher!='ProCoon']">
      <entry ct="{$contentType}" l="{$localisation}" o="{$objectId}" valid="true">
        <result>OK</result>
        <content>
          <object>
            <id>
              <xsl:value-of select="$objectId"/>
            </id>
            <!--
              xsl:copy-of select="Asset[Language = '' or Language='en_Philips' or (Language = 'en_US' and
              ResourceType='GLL') or (Language = 'en_US' and ResourceType='PSS')][Publisher!='ProCoon'] "/
            -->
            <xsl:for-each select="Asset[License!='Obsolete'][Language = ''                                                              or Language='en_Philips'                                                              or (Language = 'en_US' and ResourceType=('GLL', 'MSD', 'WRN', 'DOC', 'INI', 'SMA', 'L3D', 'CER'))                                                              or (Language = 'en_US' and ResourceType='PSS')][Publisher!='ProCoon']">
              <xsl:sort order="ascending" select="ResourceType"/>
              <xsl:sort order="ascending" select="Language"/>
              <xsl:copy-of copy-namespaces="no" select="."/>
            </xsl:for-each>
          </object>
        </content>
        <currentmasterlastmodified_ts>
          <sql:execute-query xmlns:sql="http://apache.org/cocoon/SQL/2.0">
            <sql:query>
              select TO_CHAR(masterlastmodified_ts,'yyyy-mm-dd"T"hh24:mi:ss') masterlastmodified_ts
              from octl where content_type='<xsl:value-of select="$contentType"/>'
              and localisation='<xsl:value-of select="$localisation"/>'
              and object_id='<xsl:value-of select="$objectId"/>'
            </sql:query>
          </sql:execute-query>
        </currentmasterlastmodified_ts>
        <currentlastmodified_ts/>
        <process/>
        <!-- This will only be ran when this entry is valid. Therefore, using importExecDelta-->
        <octl-attributes>
          <lastmodified_ts>
            <xsl:value-of select="$processTimestamp"/>
          </lastmodified_ts>
          <masterlastmodified_ts>
            <xsl:value-of select="$masterLastmodifiedTimestamp/value"/>
          </masterlastmodified_ts>
          <status>Loaded</status>
        </octl-attributes>
      </entry>
    </xsl:if>

    <!-- AssetList  C O N T E N T  T Y P E  localised  -->
    <xsl:for-each-group group-by="Language" select="Asset[string-length(Language) = 5 and not(ResourceType=('GLL', 'MSD', 'WRN', 'DOC', 'INI', 'SMA', 'L3D' , 'CER') ) ][Publisher!='ProCoon'] ">
      <xsl:variable name="contentType" select=" 'AssetList' "/>
      <xsl:variable name="localisation" select="current-grouping-key()"/>
      <entry ct="{$contentType}" l="{$localisation}" o="{$objectId}" valid="true">
        <result>OK</result>
        <content>
          <object>
            <id>
              <xsl:value-of select="$objectId"/>
            </id>
            <xsl:for-each select="current-group()[License!='Obsolete']">
              <xsl:sort order="ascending" select="ResourceType"/>
              <xsl:copy-of copy-namespaces="no" select="."/>
            </xsl:for-each>
          </object>
        </content>
        <currentmasterlastmodified_ts>
          <sql:execute-query xmlns:sql="http://apache.org/cocoon/SQL/2.0">
            <sql:query>
              select TO_CHAR(masterlastmodified_ts,'yyyy-mm-dd"T"hh24:mi:ss') masterlastmodified_ts
              from octl where content_type='<xsl:value-of select="$contentType"/>'
              and localisation='<xsl:value-of select="$localisation"/>'
              and object_id='<xsl:value-of select="$objectId"/>'
            </sql:query>
          </sql:execute-query>
        </currentmasterlastmodified_ts>
        <currentlastmodified_ts/>
        <process/>
        <!-- This will only be ran when this entry is valid. Therefore, using importExecDelta-->
        <octl-attributes>
          <lastmodified_ts>
            <xsl:value-of select="$processTimestamp"/>
          </lastmodified_ts>
          <masterlastmodified_ts>
            <xsl:value-of select="$masterLastmodifiedTimestamp/value"/>
          </masterlastmodified_ts>
          <status>Loaded</status>
        </octl-attributes>
      </entry>
    </xsl:for-each-group>
  </xsl:template>

</xsl:stylesheet><xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0">

  <xsl:param as="xs:string" name="sourceDir"/>

  <xsl:template match="/">
    <page>
      <xsl:apply-templates select="//dir:file"/>
    </page>
  </xsl:template>

  <!-- Delete the file -->
  <xsl:template match="dir:file">
    <shell:delete xmlns:shell="http://apache.org/cocoon/shell/1.0">
      <shell:source>
        <xsl:value-of select="concat($sourceDir,'/',@name)"/>
      </shell:source>
    </shell:delete>
  </xsl:template>

</xsl:stylesheet><xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0">
    <xsl:output encoding="UTF-8" indent="yes" method="xml" version="1.0"/>
    <xsl:param as="xs:string" name="sourceDir"/>
    <xsl:param as="xs:string" name="targetDir"/>
    <xsl:param name="limit"/>
  
    <xsl:variable name="l-limit" select="if (matches($limit,'\d+')) then number($limit) else 0"/>

    <xsl:template match="/">
        <page>
          <xsl:for-each select="//dir:file[$l-limit=0 or position() &lt;= $l-limit]">
            <shell:move xmlns:shell="http://apache.org/cocoon/shell/1.0" overwrite="true">
              <shell:source><xsl:value-of select="concat($sourceDir,'/',@name)"/></shell:source>
              <shell:target><xsl:value-of select="concat($targetDir,'/',@name)"/></shell:target>
            </shell:move>
          </xsl:for-each>
            <!-- <xsl:apply-templates select="//dir:file"/>  -->
        </page>
    </xsl:template>
<!-- 
    <xsl:template match="dir:file">
        <shell:move overwrite="true">
            <shell:source><xsl:value-of select="concat($sourceDir,'/',@name)"/></shell:source>
            <shell:target><xsl:value-of select="concat($targetDir,'/',@name)"/></shell:target>
        </shell:move>
    </xsl:template>
 -->
</xsl:stylesheet><xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0">

  <xsl:param name="timestamp"/>
  <xsl:param name="process"/>
  <xsl:param name="sourceDir"/>
  <xsl:param name="targetDir"/>

  <xsl:template match="/">
    <root>
      <xsl:variable name="list">
        <xsl:apply-templates/>
      </xsl:variable>
      <xsl:for-each-group group-by="substring(@name, 23)" select="$list/entry">
        <xsl:apply-templates mode="process" select="current-group()[last()]"/>
        <xsl:apply-templates mode="discard" select="current-group()[position() lt last()]"/>
      </xsl:for-each-group>
    </root>
  </xsl:template>
  
  <xsl:template match="//dir:file">
    <entry>
      <xsl:variable name="filebase" select="substring-before(@name, '.')"/>
      <xsl:variable name="filedate" select="substring(@name, string-length($filebase)-13, 14)"/>
      <xsl:variable name="filetype" select="substring-before(@name, $filedate)"/>
      <xsl:attribute name="filedate" select="$filedate"/>
      <xsl:attribute name="filetype" select="$filetype"/>
      <xsl:attribute name="name" select="@name"/>
      <xsl:attribute name="fileExt" select="substring-after(@name, '.')"/>
      <xsl:attribute name="filebase" select="$filebase"/>
    </entry>
  </xsl:template>
  
  <xsl:template match="entry" mode="process">
    <cinclude:include xmlns:cinclude="http://apache.org/cocoon/include/1.0" src="cocoon:/{$process}/{@name}"/>
  </xsl:template>

  <xsl:template match="entry" mode="discard">
    <shell:move xmlns:shell="http://apache.org/cocoon/shell/1.0" overwrite="true">
      <shell:source>
        <xsl:value-of select="concat($sourceDir,'/',@name)"/>
      </shell:source>
      <shell:target>
        <xsl:value-of select="concat($targetDir,'/',@name)"/>
      </shell:target>
    </shell:move>
  </xsl:template>
</xsl:stylesheet><xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0">
	<xsl:output encoding="UTF-8" indent="yes" method="xml" version="1.0"/>
	<xsl:param name="output-folder"/> 
	<xsl:param name="process"/> 
		
	<xsl:template match="/">
		<root>
			<xsl:variable name="list">
				<list>
					<xsl:apply-templates/>
				</list>
			</xsl:variable>
			<xsl:for-each-group group-by="substring(@name, 23)" select="$list/list/entry">
			  <xsl:for-each select="current-group()">
				<xsl:if test="count(current-group()) = position()">
		           <cinclude:include xmlns:cinclude="http://apache.org/cocoon/include/1.0" src="cocoon:/{$process}/{$output-folder}/{current-group()/@name}"/>
		        </xsl:if>
		      </xsl:for-each>
			</xsl:for-each-group>
		</root>
	</xsl:template>

	<xsl:template match="//dir:file">
		<entry>
			<xsl:variable name="filebase" select="substring-before(@name, '.')"/>
			<xsl:variable name="filedate" select="substring(@name, string-length($filebase)-13, 14)"/>
			<xsl:variable name="filetype" select="substring-before(@name, $filedate)"/>
			<xsl:attribute name="filedate" select="$filedate"/>
			<xsl:attribute name="filetype" select="$filetype"/>
			<xsl:attribute name="name" select="@name"/>
			<xsl:attribute name="fileExt" select="substring-after(@name, '.')"/>
			<xsl:attribute name="filebase" select="$filebase"/>		
		</entry>
	</xsl:template>
</xsl:stylesheet><xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0">

  <xsl:param name="ct"/>
  <xsl:param name="timestamp"/>
  <xsl:param name="filename"/>    
  <xsl:param name="filestem"/>    
  <xsl:param name="work-folder"/>

  <xsl:template match="/">
    <root>
      <xsl:apply-templates/>
    </root>
  </xsl:template>

  <xsl:template match="node()[local-name()='file']">
    <xsl:if test="($filename='' and $filestem = '') or @name = $filename or ($filestem != '' and starts-with(@name,$filestem))">
      <!-- IF $FILENAME IS SET split only that file, otherwise split all files -->
      <xsl:variable name="fileextn">
        <xsl:analyze-string regex="^(.*)\.(..*)$" select="@name">
          <xsl:matching-substring>
            <xsl:value-of select="regex-group(2)"/>
          </xsl:matching-substring>
          <xsl:non-matching-substring>
            <!-- Shouldn't be possible -->
            <xsl:value-of select="'ERROR'"/>
          </xsl:non-matching-substring>
        </xsl:analyze-string>
      </xsl:variable>
      <xsl:variable name="filestem2" select="substring-before(@name,concat('.',$fileextn))"/>
      <cinclude:include xmlns:cinclude="http://apache.org/cocoon/include/1.0"><xsl:attribute name="src" select="concat('cocoon:/splitFile/',$ct,'/',$timestamp,'/',$filestem2,'.',$fileextn, '/', $work-folder)"/></cinclude:include>
    </xsl:if>
  </xsl:template>
</xsl:stylesheet><xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0">
  
  <!-- Merges the assets from multiple ProductMsg and includes the cache contents for the CTN.
  
       - ProductMsg attributes are set to the most recent found in the input
       - Assets are grouped by ResourceType and Language, and subsequently sorted by ascending Modified tag. The last Asset
         in a group is therefore the most recent, and is to be copied to the output stream
  -->   
  
  <xsl:template match="node()|@*" mode="#all">
    <xsl:copy copy-namespaces="no">
      <xsl:apply-templates mode="#current" select="node()|@*"/>
    </xsl:copy>
  </xsl:template>
  
  <xsl:template match="root">
    <root>
      <delta>
	    <ProductsMsg>
	      <xsl:variable name="ctn" select="delta/ProductsMsg[1]/Product/CTN"/>
	      
	      <xsl:attribute name="docTimestamp" select="delta/ProductsMsg[1]/@docTimestamp"/>
          <xsl:attribute name="version" select="delta/ProductsMsg[1]/@version"/>
	      
	      <Product>
	        <CTN><xsl:value-of select="$ctn"/></CTN>
	        <!-- Merge all assets from inbox files + cache and copy the most recent version for every type/locale -->
	        <xsl:for-each-group group-by="concat(ResourceType, '-', Language)" select="*/ProductsMsg/Product/Asset">
	          <xsl:sort order="ascending" select="ResourceType"/>
              <xsl:sort order="ascending" select="Language"/>
              <xsl:for-each select="current-group()">
                <xsl:sort order="descending" select="Modified"/>
                <xsl:if test="position() = 1">
                  <xsl:apply-templates select="."/>
                </xsl:if>
              </xsl:for-each>
	        </xsl:for-each-group>
	      </Product>  
	    </ProductsMsg>
      </delta>
      <xsl:apply-templates select="cache"/>
    </root>
  </xsl:template>
    
  <xsl:template match="cache/ProductsMsg/Product">
    <xsl:copy copy-namespaces="no">
      <xsl:apply-templates select="CTN"/>
      <xsl:apply-templates select="Asset">
        <xsl:sort order="ascending" select="ResourceType"/>
        <xsl:sort order="ascending" select="Language"/>
      </xsl:apply-templates>
    </xsl:copy>
  </xsl:template>
  
</xsl:stylesheet><xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0">

  <!--
    Merge ProductMsg from inbox with ProductMsg from cache. 
  -->
  <xsl:template match="@*|node()">
    <xsl:copy>
      <xsl:apply-templates select="@*|node()"/>
    </xsl:copy>
  </xsl:template>
  
  <xsl:template match="AssetsToCompare">
    <xsl:copy copy-namespaces="no">
      <!-- First ProductMsg is the inbox version. Merge the assets with the cached assets. -->
      <xsl:apply-templates mode="merge" select="ProductsMsg[1]"/>
      <xsl:apply-templates select="ProductsMsg[2]"/>
      <!-- Save the merged version for storage -->
      <store>
        <xsl:apply-templates mode="merge" select="ProductsMsg[1]"/>
      </store>
    </xsl:copy>
  </xsl:template>
  
  <xsl:template match="ProductsMsg" mode="merge">
    <xsl:copy copy-namespaces="no">
      <xsl:apply-templates select="@*"/>
      <xsl:apply-templates mode="merge" select="Product">
        <xsl:with-param name="cached-assets" select="following-sibling::ProductsMsg/Product/Asset"/>
      </xsl:apply-templates>
    </xsl:copy>
  </xsl:template>

  <xsl:template match="Product" mode="merge">
    <xsl:param name="cached-assets"/>
    <xsl:copy>
      <xsl:apply-templates select="@*|node()"/>
      <!-- Add cached assets that are not in the inbox Product to get a full Asset list for the product -->
      <xsl:apply-templates select="for $a in $cached-assets                                    return                                     if (empty(Asset[ResourceType=$a/ResourceType][Language=$a/Language]))                                     then                                       $a                                     else                                       ()"/>
    </xsl:copy>
  </xsl:template>
  
</xsl:stylesheet><xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0">
  
  <!--
    Convert the aggregated messages from the inbox and cache into a structure that is processed in the comparison.
  -->
  <xsl:template match="@*|node()" mode="#all">
    <xsl:copy copy-namespaces="no">
      <xsl:apply-templates mode="#current" select="@*|node()"/>
    </xsl:copy>
  </xsl:template>

  <xsl:template match="AssetsToCompare">
    <root>
      <delta>
        <xsl:apply-templates select="ProductsMsg[1]"/>
      </delta>
      <cache>
        <xsl:apply-templates select="ProductsMsg[2]"/>
      </cache>  
    </root>
  </xsl:template>
    
</xsl:stylesheet><xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0">

  <xsl:param name="files"/>
  <xsl:param name="source-folder"/>
  <xsl:param name="cache-folder"/>
  <xsl:param name="processed-folder"/>

  <xsl:template match="@*|node()">
    <xsl:copy>
      <xsl:apply-templates select="@*|node()"/>
    </xsl:copy>
  </xsl:template>

  <xsl:template match="/">
    <root>
      <xsl:variable name="files-to-merge" select="tokenize($files, ' ')"/>
      <delta>
        <xsl:for-each select="$files-to-merge">
          <cinclude:include xmlns:cinclude="http://apache.org/cocoon/include/1.0">
            <xsl:attribute name="src" select="concat('cocoon:/readFile/', concat($source-folder, '/'), .)"/>
          </cinclude:include>
          <shell:move xmlns:shell="http://apache.org/cocoon/shell/1.0">
            <shell:source>
              <xsl:value-of select="concat($source-folder, '/', .)"/>
            </shell:source>
            <shell:target>
              <xsl:value-of select="concat($processed-folder, '/', .)"/>
            </shell:target>
          </shell:move>
        </xsl:for-each>
      </delta>

      <cache>
        <cinclude:include xmlns:cinclude="http://apache.org/cocoon/include/1.0">
          <xsl:attribute name="src" select="concat('cocoon:/readFile/', concat($cache-folder, '/'), replace($files-to-merge[1], '.+\.batch_\d+\.(.+)\.xml', '$1'), '.xml')"/>
        </cinclude:include>
      </cache>
    </root>
  </xsl:template>
</xsl:stylesheet><xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0">

  <xsl:param name="source"/>
  
  <xsl:template match="@*|node()">
    <xsl:copy>
      <xsl:apply-templates select="@*|node()"/>
    </xsl:copy>
  </xsl:template>
  
  <!-- Remove files that are identical to the cached version -->
  <xsl:template match="remove">
    <xsl:copy>
    <xsl:apply-templates select="@*"/>
    <shell:delete xmlns:shell="http://apache.org/cocoon/shell/1.0">
      <shell:source>
        <xsl:value-of select="concat($source,replace(@ctn,'/','_'),'.xml')"/>
      </shell:source>
    </shell:delete>
    </xsl:copy>
  </xsl:template>

  <!-- Store a merged version -->
  <xsl:template match="store">
    <source:write xmlns:source="http://apache.org/cocoon/source/1.0">
      <source:source>
        <xsl:value-of select="$source"/>
        <xsl:value-of select="replace(ProductsMsg/Product/CTN,'/','_')"/>
        <xsl:text>.xml</xsl:text>
      </source:source>
      <source:fragment>
        <xsl:apply-templates select="ProductsMsg"/>
      </source:fragment></source:write></xsl:template></xsl:stylesheet></report>